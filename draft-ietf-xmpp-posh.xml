<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY I-D.ietf-dane-srv PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dane-srv.xml">
  <!ENTITY I-D.ietf-websec-key-pinning PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-websec-key-pinning.xml">
  <!ENTITY I-D.ietf-xmpp-dna PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-xmpp-dna.xml">
  <!ENTITY rfc2119 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY rfc2782 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml">
  <!ENTITY rfc2818 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2818.xml">
  <!ENTITY rfc4033 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml">
  <!ENTITY rfc4648 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
  <!ENTITY rfc5226 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
  <!ENTITY rfc5246 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
  <!ENTITY rfc5280 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml">
  <!ENTITY rfc5785 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5785.xml">
  <!ENTITY rfc6120 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6120.xml">
  <!ENTITY rfc6125 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml">
  <!ENTITY rfc6335 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6335.xml">
  <!ENTITY rfc6555 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6555.xml">
  <!ENTITY rfc6570 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6570.xml">
  <!ENTITY rfc6698 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml">
  <!ENTITY rfc6797 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6797.xml">
  <!ENTITY rfc7030 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7030.xml">
  <!ENTITY rfc7159 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml">
  <!ENTITY rfc7230 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
  <!ENTITY rfc7238 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7238.xml">
]>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<rfc category="std" docName="draft-ietf-xmpp-posh-02" ipr="trust200902">
  <front>
    <title abbrev="POSH">PKIX over Secure HTTP (POSH)</title>
    <author initials="M." surname="Miller" fullname="Matthew Miller">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1899 Wynkoop Street, Suite 600</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80202</code>
          <country>USA</country>
        </postal>
        <email>mamille2@cisco.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>&amp;yet</organization>
      <address>
        <postal>
          <street>P.O. Box 787</street>
          <city>Parker</city>
          <region>CO</region>
          <code>80134</code>
          <country>USA</country>
        </postal>
        <email>peter@andyet.com</email>
      </address>
    </author>
    <date/>
    <area>RAI</area>
    <workgroup>XMPP Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>Jabber</keyword>
    <keyword>federation</keyword>
    <abstract>
      <t>Experience has shown that it is extremely difficult to deploy proper PKIX certificates for TLS in multi-tenanted environments, since certification authorities will not issue certificates for hosted domains to hosting services, hosted domains do not want hosting services to hold their private keys, and hosting services wish to avoid liability for holding those keys.  As a result, domains hosted in multi-tenanted environments often deploy non-HTTP applications such as email and instant messaging using certificates that identify the hosting service, not the hosted domain.  Such deployments force end users and peer services to accept a certificate with an improper identifier, resulting in obvious security implications.  This document defines two methods that make it easier to deploy certificates for proper server identity checking in non-HTTP application protocols.  The first method enables the TLS client associated with a user agent or peer application server to obtain the end-entity certificate of a hosted domain over secure HTTP as an alternative to standard PKIX techniques.  The second method enables a hosted domain to securely delegate a non-HTTP application to a hosting service using redirects provided by HTTPS itself or by a pointer in a file served over HTTPS at the hosted domain.  While this approach was developed for use in the Extensible Messaging and Presence Protocol (XMPP) as a Domain Name Association prooftype, it can be applied to any non-HTTP application protocol.</t>
    </abstract>
  </front>

  <middle>

    <section title="Introduction" anchor="intro">
      <t>We start with a thought experiment.</t>
      <t>Imagine that you work on the operations team of a hosting company that provides the "foo" service (or email or instant messaging or social networking service) for ten thousand different customer organizations.  Each customer wants their service to be identified by the customer's domain name (e.g., foo.example.com), not the hosting company's domain name (e.g., hosting.example.net).</t>
      <t>In order to properly secure each customer's "foo" service via Transport Layer Security (TLS) <xref target='RFC5246'/>, you need to obtain PKIX certificates <xref target='RFC5280'/> containing identifiers such as foo.example.com, as explained in the "CertID" specification <xref target='RFC6125'/>.  Unfortunately, you can't obtain such certificates because:</t>
      <t>
        <list style='symbols'>
          <t>Certification authorities won't issue such certificates to you because you work for the hosting company, not the customer organization.</t>
          <t>Customers won't obtain such certificates and then give them (plus the associated private keys) to you because their legal department is worried about liability.</t>
          <t>You don't want to install such certificates (plus the associated private keys) on your servers anyway because your legal department is worried about liability, too.</t>
        </list>
      </t>
      <t>Given your inability to deploy public keys / certificates containing the right identifiers, your back-up approach has always been to use a certificate containing hosting.example.net as the identifier.  However, more and more customers and end users are complaining about warning messages in user agents and the inherent security issues involved with taking a "leap of faith" to accept the identity mismatch between the source domain (foo.example.com) and the delegated domain (hosting.example.net).</t>
      <t>This situation is both insecure and unsustainable.  You have investigated the possibility of using DNS Security <xref target="RFC4033"/> and DNS-Based Authentication of Named Entities (DANE) <xref target="RFC6698"/> to solve the problem.  However, your customers and your operations team have told you that it will be several years before they will be able to deploy DNSSEC and DANE for all of your customers (because of tooling updates, slow deployment of DNSSEC at some top-level domains, etc.).  The product managers in your company are pushing you to find a method that can be deployed more quickly to overcome the lack of proper server identity checking for your hosted customers.</t>
      <t>One possible approach that your team has investigated is to ask each customer to provide the public key / certificate for the "foo" service at a special HTTPS URL on their website ("https://foo.example.com/.well-known/posh.foo.json" is one possibility).  This could be a public key that you generate for the customer, but because the customer hosts it via HTTPS, any user agent can find that public key and check it against the public key you provide during TLS negotiation for the "foo" service (as one added benefit, the customer never needs to hand you a private key).  Alternatively, the customer can redirect requests for that special HTTPS URL to an HTTPS URL at your own website, thus making it explicit that they have delegated the "foo" service to you.</t>
      <t>The approach sketched out above, called POSH ("PKIX Over Secure HTTP"), is explained in the remainder of this document.  While this approach was developed for use in the Extensible Messaging and Presence Protocol (XMPP) as a prooftype for Domain Name Associations (DNA) <xref target="I-D.ietf-xmpp-dna"/>, it can be applied to any non-HTTP application protocol.</t>
    </section>

    <section title="Terminology" anchor="terms">
      <t>This document inherits security terminology from <xref target="RFC5280"/>.  The terms "source domain", "derived domain", "reference identifier", and "presented identifier" are used as defined in the "CertID" specification <xref target="RFC6125"/>.</t>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
    </section>

    <section title="Obtaining Verification Materials" anchor="obtain">
      <t>Server identity checking (see <xref target='RFC6125'/>) involves three different aspects:</t>
      <t>
        <list style='numbers'>
          <t>A proof of the TLS server's identity (in PKIX, this takes the form of a PKIX certificate <xref target='RFC5280'/>).</t>
          <t>Rules for checking the certificate (which vary by application protocol, although <xref target='RFC6125'/> attempts to harmonize those rules).</t>
          <t>The materials that a TLS client uses to verify the TLS server's identity or check the TLS server's proof (in PKIX, this takes the form of chaining the end-entity certificate back to a trusted root and performing all validity checks as described in <xref target='RFC5280'/>, <xref target='RFC6125'/>, and the relevant application protocol specification).</t>
        </list>
      </t>
      <t>When POSH is used, the first two aspects remain the same: the TLS server proves it identity by presenting a PKIX certificate <xref target="RFC5280"/> and the certificate is checked according to the rules defined in the appropriate application protocol specification (such as <xref target="RFC6120"/> for XMPP).  However, the TLS client obtains the materials it will use to verify the server's proof by retrieving a JSON document <xref target='RFC7159'/> containing hashes of the PKIX certificate over HTTPS (<xref target="RFC7230"/> and <xref target="RFC2818"/>) from a well-known URI <xref target="RFC5785"/>.</t>
      <t>The process for retrieving a PKIX certificate over secure HTTP is as follows.</t>
      <t>
        <list style="numbers">
          <t>The TLS client performs an HTTPS GET at the source domain to the path "/.well-known/posh.{servicedesc}.json".  The value of "{servicedesc}" is application-specific; see <xref target="iana"/> of this document for more details.  For example, if the application protocol is some hypothetical "Foo" service, then "{servicedesc}" could be "foo"; thus if a Foo client were to use POSH to verify a Foo server for the domain "foo.example.com", the HTTPS GET request would be as follows:
          <figure>
            <artwork><![CDATA[
    GET /.well-known/posh.foo.json HTTP/1.1
    Host: foo.example.com
            ]]></artwork>
          </figure>
          </t>
          <t>The source domain HTTPS server responds in one of three ways:
            <list style="symbols">
              <t>If it possesses PKIX certificate information for the requested path, it responds as detailed in <xref target="prooftype-possess"/>.</t>
              <t>If it has a reference to where the PKIX certificate information can be obtained, it responds as detailed in <xref target="prooftype-ref"/>.</t>
              <t>If it does not have any PKIX certificate information or a reference to such information for the requested path, it responds with an HTTP client error status code (e.g., 404).</t>
            </list>
          </t>
        </list>
      </t>

      <section title="Source Domain Possesses PKIX Certificate Information" anchor="prooftype-possess">
        <t>If the source domain HTTPS server possesses the certificate information, it responds to the HTTPS GET with a success status code and the message body set to a JSON document <xref target='RFC7159'/>; the document is a JSON object which MUST have the following:</t>
        <t>
          <list style="symbols">
            <t>A "fingerprints" field whose value is a JSON array of fingerprint descriptors.</t>
            <t>An "expires" field whose value is a JSON number specifying the seconds after which the TLS client ought to consider the key information to be stale (further explained under <xref target='caching'/>).</t>
          </list>
        </t>
        <t>Each included fingerprint descriptor is a JSON object, where each member name is the textual name of a hash function (as listed in <xref target='HASH-NAMES'/>) and its associated value is the base 64 encoded fingerprint hash generated using the named hash function (where the encoding adheres to the definition in Section 4 of <xref target='RFC4648'/> and where the padding bits are set to zero).  Each fingerprint descriptor MUST possess at least one named hash function.</t>
        <t>The fingerprint hash for a given hash algorithm is generated by performing the named hash function over the DER encoding of the PKIX X.509 certifiate; for example, a "sha-1" fingerprint is generated by performing the SHA-1 hash function over the DER encoding of the PKIX certificate.</t>
        <t>The following example illustrates the usage described above.</t>
        <t>
          <figure>
              <preamble>Example Content Response</preamble>
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 134

{
  "fingerprints": [
    {
      "sha-1":"UpjRI/A3afKE8/AIeTZ5o1dECTY=",
      "sha-256":"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ="
    }
  ],
  "expires": 604800
}

]]></artwork>
          </figure>
        </t>
        <t>The "expires" value is a hint regarding the expiration of the keying materials. It MUST be a non-negative integer. If no "expires" field is included or its value is less than 1, a TLS client SHOULD consider these verification materials invalid.  See <xref target='caching'/> for how to reconcile this "expires" field with the reference's "expires" field.</t>
      </section>

      <section title="Source Domain References PKIX Certificate" anchor="prooftype-ref">
        <t>If the source domain HTTPS server has a reference to the certificate information, it responds to the HTTPS GET with a success status code and message body set to a JSON document.  The document is a JSON object which MUST contain the following:</t>
        <t>
          <list style='symbols'>
            <t>A "url" field whose value is the HTTPS URL where TLS clients can obtain the actual certificate information.</t>
            <t>An "expires" field whose value is a JSON number specifying the number of seconds after which the TLS client ought to consider the delegation to be stale (further explained under <xref target='caching'/>).</t>
          </list>
        </t>
        <t>
          <figure>
            <preamble>Example Reference Response</preamble>
            <artwork><![CDATA[
HTTP/1.1 200 Ok
Content-Type: application/json
Content-Length: 79

{
  "url":"https://hosting.example.net/.well-known/posh.foo.json",
  "expires":86400
}
              ]]></artwork>
          </figure>
        </t>
        <t>The client performs an HTTPS GET for the URL specified in the "url" field value.  The HTTPS server for the URL to which the client has been redirected responds to the request with a JSON document containing fingerprints as described in <xref target='prooftype-possess'/>.  The content retrieved from the "url" location MUST NOT itself be a reference (i.e., containing a "url" field instead of a "fingerprints" field), in order to prevent circular delegations.</t>
        <t><list style='empty'><t>Note: The JSON document returned by the source domain HTTPS server MUST contain either a reference or a fingerprints document, but MUST NOT contain both.</t></list></t>
        <t><list style='empty'><t>Note: See <xref target='security'/> for discussion about HTTPS redirects.</t></list></t>
        <t>The "expires" value is a hint regarding the expiration of the source domain's delegation of service to the delegated domain. It MUST be a non-negative integer. If no "expires" field is included or its value is less than 1, a TLS client SHOULD consider the delegation invalid.  See <xref target='caching'/> for guidelines about reconciling this "expires" field with the "expires" field of the fingerprints document.</t>
      </section>
      
      <section title="Performing Verification" anchor="prooftype-verify">
        <t>The TLS client compares the PKIX information obtained from the TLS server against each fingerprint descriptor object in the POSH results, until a match is found or the collection of POSH verification materials is exhausted.  If none of the fingerprint descriptor objects match the TLS server PKIX information, the TLS client SHOULD reject the connection (however, the TLS client might still accept the connection if other verification schemes are successful).</t>
      </section>
    </section>

    <section title="Secure Delegation" anchor="delegation">
      <t>The delegation from the source domain to the delegated domain can be considered secure if the certificate offered by the TLS server matches the POSH certificate, regardless of how the POSH certificate is obtained.</t>
    </section>

    <section title="Order of Operations" anchor="order">
      <t>In order for the TLS client to perform verification of reference identifiers without potentially compromising data, POSH processes MUST be complete before any application-level data is exchanged for the source domain.  The TLS client SHOULD perform all POSH retrievals before opening any socket connections to the application protocol server.  For application protocols that use DNS SRV (including queries for TLSA records in concert with SRV records as described in <xref target='I-D.ietf-dane-srv'/>), the POSH processes ideally ought to be done in parallel with resolving the SRV records and the addresses of any targets, similar to the "happy eyeballs" approach for IPv4 and IPv6 <xref target='RFC6555'/>.</t>
      <t>The following diagram illustrates the possession flow:</t>
      <t>
        <figure anchor='figure-1' title='Order of Events for Possession Flow'>
          <artwork><![CDATA[
Client                     Domain                     Server
------                     ------                     ------
  |                          |                          |
  |      Request POSH        |                          |
  |------------------------->|                          |
  |                          |                          |
  | Return POSH fingerprints |                          |
  |<-------------------------|                          |
  |                          |                          |
  |                  Service TLS Handshake              |
  |<===================================================>|
  |                          |                          |
  |                     Service Data                    |
  |<===================================================>|
  |                          |                          |
          ]]></artwork>
        </figure>
      </t>
      <t>While the following diagram illustrates the reference flow:</t>
      <t>
        <figure anchor='figure-2' title='Order of Events for Reference Flow'>
          <artwork><![CDATA[
Client                     Domain                     Server
------                     ------                     ------
  |                          |                          |
  |      Request POSH        |                          |
  |------------------------->|                          |
  |                          |                          |
  |     Return POSH url      |                          |
  |<-------------------------|                          |
  |                          |                          |
  |                      Request POSH                   |
  |---------------------------------------------------->|
  |                          |                          |
  |                Return POSH fingerprints             |
  |<----------------------------------------------------|
  |                          |                          |
  |                 Service TLS Handshake               |
  |<===================================================>|
  |                          |                          |
  |                     Service Data                    |
  |<===================================================>|
  |                          |                          |
          ]]></artwork>
        </figure>
      </t>
    </section>

    <section title="Caching Results" anchor="caching">
      <t>The TLS client MUST NOT cache results (reference or fingerprints) indefinitely.  If the source domain returns a reference, the TLS client MUST use the lower of the two "expires" values when determining how long to cache results (i.e., if the reference "expires" value is lower than the fingerprints "expires" value, honor the reference "expires" value).  Once the TLS client considers the results stale, it needs to perform the entire POSH process again starting with the HTTPS GET to the source domain.  The TLS client MAY use a lower value than any provided in the "expires" field(s), or not cache results at all.</t>
      <t>The TLS client SHOULD NOT rely on HTTP caching mechanisms, instead using the expiration hints provided in the POSH reference document or fingerprints documents.  To that end, the HTTPS servers for source domains and derived domains SHOULD specify a 'Cache-Control' header indicating a very short duration (e.g., max-age=60) or "no-cache" to indicate that the response (redirect, reference, or content) is not appropriate to cache at the HTTP level.</t>
    </section>

    <section title="Alternates and Roll-over" anchor="rollover">
      <t>To indicate alternate PKIX certificates (such as when an existing certificate will soon expire), the returned fingerprints document MAY contain multiple fingerprint descriptors.  The fingerprints SHOULD be ordered with the most relevant certificate first as determined by the application service operator (e.g., the renewed certificate), followed by the next most relevant certificate (e.g., the certificate soonest to expire).  Here is an example:</t>
      <figure>
        <artwork><![CDATA[
{
  "fingerprints": [
    {
      "sha-1":"UpjRI/A3afKE8/AIeTZ5o1dECTY=",
      "sha-256":"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ"
    },
    {
      "sha-1":"T29tGO9d7kxbfWnUaac8+5+ICLM=",
      "sha-256":"otyLADSKjRDjVpj8X7/hmCAD5C7Qe+PedcmYV7cUncE="
    }
  ],
  "expires": 806400
}        ]]></artwork>
      </figure>
    </section>

    <section title="IANA Considerations" anchor="iana">
      <t>This document registers a well-known URI <xref target='RFC5785'/> for protocols that use POSH.  The completed template follows.</t>
      <t>
        <list style='empty'>
          <t>
            <list style='hanging'>
              <t hangText='URI suffix:'>posh.</t>
              <t hangText='Change controller:'>IETF</t>
              <t hangText='Specification document:'>[[ this document ]]</t>
              <t hangText='Related information:'>Because the "posh." string is merely a prefix, protocols that use POSH need to register particular URIs that are prefixed with the "posh." string.</t>
            </list>
          </t>
        </list>
      </t>
      <t>Note that the registered URI is "posh." (with a trailing dot).  This is merely a prefix to be placed at the front of well-known URIs <xref target='RFC5785'/> registered by protocols that use POSH, which themselves are responsible for the relevant registrations with the IANA.  The URIs registered by such protocols SHOULD match the URI template <xref target="RFC6570"/> path "/.well-known/posh.{servicedesc}.json"; that is, begin with "posh." and end with ".json" (indicating a media type of application/json <xref target='RFC7159'/>).</t>
      <t>For POSH-using protocols that rely on DNS SRV records <xref target='RFC2782'/>, the "{servicedesc}" part of the well-known URI SHOULD be "{service}.{proto}", where the "{service}" is the DNS SRV "Service" prepended by the underscore character "_" and the "{proto}" is the DNS SRV "Proto" also prepended by the underscore character "_".  As an example, the well-known URI for XMPP server-to-server connections would be "posh._xmpp-server._tcp.json" since XMPP <xref target='RFC6120'/> registers a service name of "xmpp-server" and uses TCP as the underlying transport protocol.</t>  
      <t>For other POSH-using protocols, the "{servicedesc}" part of the well-known URI can be any unique string or identifier for the protocol, which might be a service name registered with the IANA in accordance with <xref target='RFC6335'/> or which might be an unregistered name.  As an example, the well-known URI for the mythical "Foo" service could be "posh.foo.json".</t>
      <t>Note: As explained in <xref target='RFC5785'/>, the IANA registration policy <xref target='RFC5226'/> for well-known URIs is Specification Required.</t>  
    </section>

    <section title="Security Considerations" anchor="security">
      <t>This document supplements but does not supersede the security considerations provided in specifications for application protocols that decide to use POSH (e.g., <xref target="RFC6120"/> and <xref target="RFC6125"/> for XMPP).  Specifically, the security of requests and responses sent via HTTPS depends on checking the identity of the HTTP server in accordance with <xref target="RFC2818"/>.  Additionally, the security of POSH can benefit from other HTTP hardening protocols, such as HSTS <xref target="RFC6797"/> and key pinning <xref target="I-D.ietf-websec-key-pinning"/>, especially if the TLS client shares some information with a common HTTPS implementation (e.g., platform-default web browser).</t>
      <t>Note well that POSH is used by a TLS client to obtain the public key of a TLS server to which it might connect for a particular application protocol such as IMAP or XMPP.  POSH does not enable a hosted domain to transfer private keys to a hosting service via HTTPS.  POSH also does not enable a TLS server to engage in certificate enrollment with a certification authority via HTTPS, as is done in Enrollment over Secure Transport <xref target='RFC7030'/>.</t>
      <t>A web server at the source domain might redirect an HTTPS request to another URL.  The location provided in the redirect response MUST specify an HTTPS URL.  Source domains SHOULD use only temporary redirect mechanisms, such as HTTP status codes 302 (Found) and 307 (Temporary Redirect).  Clients MAY treat any redirect as temporary, ignoring the specific semantics for 301 (Moved Permanently) and 308 (Permanent Redirect) <xref target='RFC7238'/>.  To protect against circular references, clients MUST NOT follow an infinite number of redirects.  It is RECOMMENDED that clients follow no more than 10 redirects, although applications or implementations can require that fewer redirects be followed.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">
      &rfc2119;
      &rfc2818;
      &rfc4648;
      &rfc5246;
      &rfc5280;
      &rfc5785;
      &rfc6125;
      &rfc7159;
      &rfc7230;
    </references>

    <references title="Informative References">
      &I-D.ietf-dane-srv;
      &I-D.ietf-websec-key-pinning;
      &I-D.ietf-xmpp-dna;
      &rfc2782;
      &rfc4033;
      &rfc5226;
      &rfc6120;
      &rfc6335;
      &rfc6555;
      &rfc6570;
      &rfc6698;
      &rfc6797;
      &rfc7030;
      &rfc7238;

      <reference anchor='HASH-NAMES' target='http://www.iana.org/assignments/hash-function-text-names/hash-function-text-names.xhtml'>
        <front>
          <title>Hash Function Textual Names</title>
          <author/>
          <date/>
        </front>
      </reference>
    </references>

    <section title="Acknowledgements" anchor="acks">
      <t>Many thanks to Thijs Alkemade, Philipp Hancke, Joe Hildebrand, and Tobias Markmann for their implementation feedback.  Thanks also to Dave Cridland, Chris Newton, Max Pritikin, and Joe Salowey for their input on the specification.</t>
    </section>

  </back>
</rfc>
