<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc2119 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY rfc2782 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml">
  <!ENTITY rfc2818 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2818.xml">
  <!ENTITY rfc4033 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml">
  <!ENTITY rfc4648 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
  <!ENTITY rfc5226 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
  <!ENTITY rfc5246 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
  <!ENTITY rfc5280 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml">
  <!ENTITY rfc5785 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5785.xml">
  <!ENTITY rfc6120 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6120.xml">
  <!ENTITY rfc6125 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml">
  <!ENTITY rfc6335 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6335.xml">
  <!ENTITY rfc6555 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6555.xml">
  <!ENTITY rfc6570 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6570.xml">
  <!ENTITY rfc6698 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml">
  <!ENTITY rfc6797 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6797.xml">
  <!ENTITY rfc7030 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7030.xml">
  <!ENTITY rfc7159 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml">
  <!ENTITY rfc7230 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
  <!ENTITY rfc7469 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7469.xml">
  <!ENTITY rfc7538 PUBLIC "" "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7538.xml">
]>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<rfc category="std" docName="draft-ietf-xmpp-posh-05" ipr="trust200902">
  <front>
    <title abbrev="POSH">PKIX over Secure HTTP (POSH)</title>
    <author initials="M." surname="Miller" fullname="Matthew Miller">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1899 Wynkoop Street, Suite 600</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80202</code>
          <country>USA</country>
        </postal>
        <email>mamille2@cisco.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>&amp;yet</organization>
      <address>
        <email>peter@andyet.com</email>
        <uri>https://andyet.com/</uri>
      </address>
    </author>
    <date/>
    <area>RAI</area>
    <workgroup>XMPP Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>Jabber</keyword>
    <keyword>federation</keyword>
    <abstract>
      <t>Experience has shown that it is extremely difficult to deploy proper PKIX certificates for TLS in multi-tenanted environments.  As a result, domains hosted in such environments often deploy applications using certificates that identify the hosting service, not the hosted domain.  Such deployments force end users and peer services to accept a certificate with an improper identifier, resulting in obvious security implications.  This document defines two methods that make it easier to deploy certificates for proper server identity checking in non-HTTP application protocols.  While these methods developed for use in the Extensible Messaging and Presence Protocol (XMPP) as a Domain Name Association (DNA) prooftype, they might also be usable in other non-HTTP application protocols.</t>
    </abstract>
  </front>

  <middle>

    <section title="Introduction" anchor="intro">
      <t>We begin with a thought experiment.</t>
      <t>Imagine that you work on the operations team of a hosting company that provides instances of the hypothetical "Secure Protocol for Internet Content Exchange" (SPICE) service for ten thousand different customer organizations.  Each customer wants their instance to be identified by the customer's domain name (e.g., bar.example.com), not the hosting company's domain name (e.g., hosting.example.net).</t>
      <t>In order to properly secure each customer's SPICE instance via Transport Layer Security (TLS) <xref target='RFC5246'/>, you need to obtain PKIX certificates <xref target='RFC5280'/> containing identifiers such as bar.example.com, as explained in the "CertID" specification <xref target='RFC6125'/>.  Unfortunately, you can't obtain such certificates because:</t>
      <t>
        <list style='symbols'>
          <t>Certification authorities won't issue such certificates to you because you work for the hosting company, not the customer organization.</t>
          <t>Customers won't obtain such certificates and then give them (plus the associated private keys) to you because their legal department is worried about liability.</t>
          <t>You don't want to install such certificates (plus the associated private keys) on your servers anyway because your legal department is worried about liability, too.</t>
          <t>Even if your legal department is happy, this still means managing one certificate for each customer across the infrastructure, contributing to a large administrative load.</t>
        </list>
      </t>
      <t>Given your inability to deploy public keys / certificates containing the right identifiers, your back-up approach has always been to use a certificate containing hosting.example.net as the identifier.  However, more and more customers and end users are complaining about warning messages in user agents and the inherent security issues involved with taking a "leap of faith" to accept the identity mismatch between what <xref target='RFC6125'/> calls the Source Domain (bar.example.com) and the Delegated Domain (hosting.example.net).</t>
      <t>This situation is both insecure and unsustainable.  You have investigated the possibility of using DNS Security <xref target="RFC4033"/> and DNS-Based Authentication of Named Entities (DANE) <xref target="RFC6698"/> to solve the problem.  However, your customers and your operations team have told you that it will be several years before they will be able to deploy DNSSEC and DANE for all of your customers (because of tooling updates, slow deployment of DNSSEC at some top-level domains, etc.).  The product managers in your company are pushing you to find a method that can be deployed more quickly to overcome the lack of proper server identity checking for your hosted customers.</t>
      <t>One possible approach that your team has investigated is to ask each customer to provide the public key / certificate for its SPICE service at a special HTTPS URL on their website ("https://bar.example.com/.well-known/posh.spice.json" is one possibility).  This could be a public key that you generate for the customer, but because the customer hosts it via HTTPS, any user agent can find that public key and check it against the public key you provide during TLS negotiation for the SPICE service (as one added benefit, the customer never needs to hand you a private key).  Alternatively, the customer can redirect requests for that special HTTPS URL to an HTTPS URL at your own website, thus making it explicit that they have delegated the SPICE service to you.</t>
      <t>The approach sketched out above, called POSH ("PKIX Over Secure HTTP"), is explained in the remainder of this document.  While this approach was developed for use in the Extensible Messaging and Presence Protocol (XMPP) as a prooftype for Domain Name Associations (DNA) <xref target="I-D.ietf-xmpp-dna"/>, it can be applied to any non-HTTP application protocol.</t>
    </section>

    <section title="Terminology" anchor="terms">
      <t>This document inherits security terminology from <xref target="RFC5280"/>.  The terms "Source Domain", "Delegated Domain", "Derived Domain", and "Reference Identifier" are used as defined in the "CertID" specification <xref target="RFC6125"/>.</t>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
      <t>Additionally, this document uses the following terms:
        <list style="hanging">
          <t hangText="POSH client:">The client utilizing the application service (e.g., an XMPP client).  It relies on the protocol defined herein to verify the POSH server's identity.</t>
          <t hangText="POSH server:">The server hosting the application service (e.g., an XMPP server).  It expects clients to rely on the protocol defined herein to verify its identity.</t>
        </list>
      </t>
    </section>

    <section title="Obtaining Verification Materials" anchor="obtain">
      <t>Server identity checking (see <xref target='RFC6125'/>) involves three different aspects:</t>
      <t>
        <list style='numbers'>
          <t>A proof of the POSH server's identity (in PKIX, this takes the form of a PKIX end-entity certificate <xref target='RFC5280'/>).</t>
          <t>Rules for checking the certificate (which vary by application protocol, although <xref target='RFC6125'/> attempts to harmonize those rules).</t>
          <t>The materials that a POSH client uses to verify the POSH server's identity or check the POSH server's proof (in PKIX, this takes the form of chaining the end-entity certificate back to a trusted root and performing all validity checks as described in <xref target='RFC5280'/>, <xref target='RFC6125'/>, and the relevant application protocol specification).</t>
        </list>
      </t>
      <t>When POSH is used, the first two aspects remain the same: the POSH server proves its identity by presenting a PKIX certificate <xref target="RFC5280"/> and the certificate is checked according to the rules defined in the appropriate application protocol specification (such as <xref target="RFC6120"/> for XMPP).  However, the POSH client obtains the materials it will use to verify the server's proof by retrieving a JSON document <xref target='RFC7159'/> containing hashes of the PKIX certificate over HTTPS (<xref target="RFC7230"/> and <xref target="RFC2818"/>) from a well-known URI <xref target="RFC5785"/> at the Source Domain.  (This means that the POSH client needs to verify the certificate of the HTTPS service at the Source Domain in order to securely "bootstrap" into the use of POSH; specifically, the rules of <xref target='RFC2818'/> apply to this "bootstrapping" step to provide a secure basis for all subsequent POSH processing.)</t>
      <t>The process for retrieving a PKIX certificate over secure HTTP is as follows.</t>
      <t>
        <list style="numbers">
          <t>The POSH client performs an HTTPS GET request at the Source Domain to the path "/.well-known/posh.{servicedesc}.json".  The value of "{servicedesc}" is application-specific; see <xref target="iana"/> of this document for more details.  For example, if the application protocol is the hypothetical SPICE service, then "{servicedesc}" could be "spice"; thus if an application client were to use POSH to verify an application server for the Source Domain "bar.example.com", the HTTPS GET request would be as follows:
          <figure>
            <artwork><![CDATA[
    GET /.well-known/posh.spice.json HTTP/1.1
    Host: bar.example.com
            ]]></artwork>
          </figure>
          </t>
          <t>The Source Domain HTTPS server responds in one of three ways:
            <list style="symbols">
              <t>If it possesses PKIX certificate information for the requested path, it responds as detailed in <xref target="prooftype-possess"/>.</t>
              <t>If it has a reference to where the PKIX certificate information can be obtained, it responds as detailed in <xref target="prooftype-ref"/>.</t>
              <t>If it does not have any PKIX certificate information or a reference to such information for the requested path, it responds with an HTTP client error status code (e.g., 404).</t>
            </list>
          </t>
        </list>
      </t>

      <section title="Source Domain Possesses PKIX Certificate Information" anchor="prooftype-possess">
        <t>If the Source Domain HTTPS server possesses the certificate information, it responds to the HTTPS GET request with a success status code and the message body set to a JSON document <xref target='RFC7159'/>; the document is a JSON object which MUST have the following:</t>
        <t>
          <list style="symbols">
            <t>A "fingerprints" field whose value is a JSON array of fingerprint descriptors.</t>
            <t>An "expires" field whose value is a JSON number specifying the number of seconds after which the POSH client ought to consider the key information to be stale (further explained under <xref target='caching'/>).</t>
          </list>
        </t>
        <t>The JSON document returned MUST NOT contain a "url" field as described in <xref target='prooftype-ref'/>.</t>
        <t>Each included fingerprint descriptor is a JSON object, where each member name is the textual name of a hash function (as listed in <xref target='HASH-NAMES'/>) and its associated value is the base 64 encoded fingerprint hash generated using the named hash function (where the encoding adheres to the definition in Section 4 of <xref target='RFC4648'/> and where the padding bits are set to zero).  Each fingerprint descriptor MUST possess at least one named hash function.</t>
        <t>The fingerprint hash for a given hash algorithm is generated by performing the named hash function over the DER encoding of the PKIX X.509 certifiate; for example, a "sha-1" fingerprint is generated by performing the SHA-1 hash function over the DER encoding of the PKIX certificate.</t>
        <t>The following example illustrates the usage described above.</t>
        <t>
          <figure>
              <preamble>Example Content Response</preamble>
              <artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 134

{
  "fingerprints": [
    {
      "sha-1":"UpjRI/A3afKE8/AIeTZ5o1dECTY=",
      "sha-256":"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ="
    }
  ],
  "expires": 604800
}

]]></artwork>
          </figure>
        </t>
        <t>The "expires" value is a hint regarding the expiration of the keying materials. It MUST be a non-negative integer. If no "expires" field is included or its value is equal to 0, a POSH client SHOULD consider these verification materials invalid.  See <xref target='caching'/> for how to reconcile this "expires" field with the reference's "expires" field.</t>
      </section>

      <section title="Source Domain References PKIX Certificate" anchor="prooftype-ref">
        <t>If the Source Domain HTTPS server has a reference to the certificate information, it responds to the HTTPS GET request with a success status code and message body set to a JSON document.  The document is a JSON object which MUST contain the following:</t>
        <t>
          <list style='symbols'>
            <t>A "url" field whose value is a JSON string specifying the HTTPS URL where POSH clients can obtain the actual certificate information.</t>
            <t>An "expires" field whose value is a JSON number specifying the number of seconds after which the POSH client ought to consider the delegation to be stale (further explained under <xref target='caching'/>).</t>
          </list>
        </t>
        <t>
          <figure>
            <preamble>Example Reference Response</preamble>
            <artwork><![CDATA[
HTTP/1.1 200 Ok
Content-Type: application/json
Content-Length: 79

{
  "url":"https://hosting.example.net/.well-known/posh.spice.json",
  "expires":86400
}
              ]]></artwork>
          </figure>
        </t>
        <t>The client performs an HTTPS GET request for the URL specified in the "url" field value.  The HTTPS server for the URL to which the client has been redirected responds to the request with a JSON document containing fingerprints as described in <xref target='prooftype-possess'/>.  The content retrieved from the "url" location MUST NOT itself be a reference (i.e., containing a "url" field instead of a "fingerprints" field), in order to prevent circular delegations.</t>
        <t><list style='empty'><t>Note: See <xref target='security'/> for discussion about HTTPS redirects.</t></list></t>
        <t>The "expires" value is a hint regarding the expiration of the Source Domain's delegation of service to the Delegated Domain. It MUST be a non-negative integer. If no "expires" field is included or its value is equal to 0, a POSH client SHOULD consider the delegation invalid.  See <xref target='caching'/> for guidelines about reconciling this "expires" field with the "expires" field of the fingerprints document.</t>
      </section>
      
      <section title="Performing Verification" anchor="prooftype-verify">
        <t>The POSH client compares the PKIX information obtained from the POSH server against each fingerprint descriptor object in the POSH results, until a match is found using the hash functions that the client suports, or until the collection of POSH verification materials is exhausted.  If none of the fingerprint descriptor objects match the POSH server PKIX information, the POSH client SHOULD reject the connection (however, the POSH client might still accept the connection if other verification schemes are successful).</t>
      </section>
    </section>

    <section title="Secure Delegation" anchor="delegation">
      <t>The delegation from the Source Domain to the Delegated Domain can be considered secure if the credentials offered by the POSH server match the verification materials possessed by the client, regardless of how those materials are obtained.</t>
    </section>

    <section title="Order of Operations" anchor="order">
      <t>In order for the POSH client to perform verification of Reference Identifiers without potentially compromising data, POSH processes MUST be complete before any application-layer data is exchanged for the Source Domain.  In cases where the POSH client initiates an application-layer connection, the client SHOULD perform all POSH retrievals before initiating a connection (naturally this is not possible in cases where the POSH client receives an application-layer connection).  For application protocols that use DNS SRV (including queries for TLSA records in concert with SRV records as described in <xref target='I-D.ietf-dane-srv'/>), the POSH processes ideally ought to be done in parallel with resolving the SRV records and the addresses of any targets, similar to the "happy eyeballs" approach for IPv4 and IPv6 <xref target='RFC6555'/>.</t>
      <t>The following diagram illustrates the possession flow:</t>
      <t>
        <figure anchor='figure-1' title='Order of Events for Possession Flow'>
          <artwork><![CDATA[
Client                     Domain                     Server
------                     ------                     ------
  |                          |                          |
  |      Request POSH        |                          |
  |------------------------->|                          |
  |                          |                          |
  | Return POSH fingerprints |                          |
  |<-------------------------|                          |
  |                          |                          |
  |                  Service TLS Handshake              |
  |<===================================================>|
  |                          |                          |
  |                     Service Data                    |
  |<===================================================>|
  |                          |                          |
          ]]></artwork>
        </figure>
      </t>
      <t>While the following diagram illustrates the reference flow:</t>
      <t>
        <figure anchor='figure-2' title='Order of Events for Reference Flow'>
          <artwork><![CDATA[
Client                     Domain                     Server
------                     ------                     ------
  |                          |                          |
  |      Request POSH        |                          |
  |------------------------->|                          |
  |                          |                          |
  |     Return POSH url      |                          |
  |<-------------------------|                          |
  |                          |                          |
  |                      Request POSH                   |
  |---------------------------------------------------->|
  |                          |                          |
  |                Return POSH fingerprints             |
  |<----------------------------------------------------|
  |                          |                          |
  |                 Service TLS Handshake               |
  |<===================================================>|
  |                          |                          |
  |                     Service Data                    |
  |<===================================================>|
  |                          |                          |
          ]]></artwork>
        </figure>
      </t>
    </section>

    <section title="Caching Results" anchor="caching">
      <t>The POSH client MUST NOT cache results (reference or fingerprints) indefinitely.  If the Source Domain returns a reference, the POSH client MUST use the lower of the two "expires" values when determining how long to cache results (i.e., if the reference "expires" value is lower than the fingerprints "expires" value, honor the reference "expires" value).  Once the POSH client considers the results stale, it needs to perform the entire POSH process again starting with the HTTPS GET request to the Source Domain.  The POSH client MAY use a lower value than any provided in the "expires" field(s), or not cache results at all.</t>
      <t>The POSH client SHOULD NOT rely on HTTP caching mechanisms, instead using the expiration hints provided in the POSH reference document or fingerprints documents.  To that end, the HTTPS servers for Source Domains and Derived Domains SHOULD specify a 'Cache-Control' header indicating a very short duration (e.g., max-age=60) or "no-cache" to indicate that the response (redirect, reference, or content) is not appropriate to cache at the HTTP layer.</t>
    </section>

    <section title="Alternates and Roll-over" anchor="rollover">
      <t>To indicate alternate PKIX certificates (such as when an existing certificate will soon expire), the returned fingerprints document MAY contain multiple fingerprint descriptors.  The fingerprints SHOULD be ordered with the most relevant certificate first as determined by the application service operator (e.g., the renewed certificate), followed by the next most relevant certificate (e.g., the certificate soonest to expire).  Here is an example:</t>
      <figure>
        <artwork><![CDATA[
{
  "fingerprints": [
    {
      "sha-1":"UpjRI/A3afKE8/AIeTZ5o1dECTY=",
      "sha-256":"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ"
    },
    {
      "sha-1":"T29tGO9d7kxbfWnUaac8+5+ICLM=",
      "sha-256":"otyLADSKjRDjVpj8X7/hmCAD5C7Qe+PedcmYV7cUncE="
    }
  ],
  "expires": 806400
}        ]]></artwork>
      </figure>
      <t>Rolling over from one hosting provider to another is best handled by updating the relevant SRV records, not primarily by updating the POSH files themselves.</t>
    </section>

    <section title="Guidelines for Protocols that Use POSH" anchor="guidelines">
      <t>Protocols that use POSH will need to register well-known URIs wth the IANA in accordance with <xref target='RFC5785'/> (the IANA registration policy <xref target='RFC5226'/> for well-known URIs is Specification Required).</t>
      <t>For the sake of consistency, it would be best if the URIs registered by such protocols match the URI template <xref target="RFC6570"/> path "/.well-known/posh.{servicedesc}.json"; that is, begin with "posh." and end with ".json" (indicating a media type of application/json <xref target='RFC7159'/>).</t>
      <t>For POSH-using protocols that rely on DNS SRV records <xref target='RFC2782'/>, it would be best if the "{servicedesc}" part of the well-known URI is "{service}.{proto}", where the "{service}" is the DNS SRV "Service" prepended by the underscore character "_" and the "{proto}" is the DNS SRV "Proto" also prepended by the underscore character "_".  As an example, the well-known URI for XMPP server-to-server connections would be "posh._xmpp-server._tcp.json" since XMPP <xref target='RFC6120'/> registers a service name of "xmpp-server" and uses TCP as the underlying transport protocol.</t>  
      <t>For other POSH-using protocols, the "{servicedesc}" part of the well-known URI can be any unique string or identifier for the protocol, which might be a service name registered with the IANA in accordance with <xref target='RFC6335'/> or which might be an unregistered name.  As an example, the well-known URI for the hypothetical SPICE application could be "posh.spice.json".</t>
    </section>

    <section title="IANA Considerations" anchor="iana">
      <t>This document requests no actions of IANA. [Note to RFC Editor: please remove this section before publication.]</t>
    </section>

    <section title="Security Considerations" anchor="security">
      <t>This document supplements but does not supersede the security considerations provided in specifications for application protocols that decide to use POSH (e.g., <xref target="RFC6120"/> and <xref target="RFC6125"/> for XMPP).  Specifically, the security of requests and responses sent via HTTPS depends on checking the identity of the HTTP server in accordance with <xref target="RFC2818"/>.  Additionally, the security of POSH can benefit from other HTTP hardening protocols, such as HSTS <xref target="RFC6797"/> and key pinning <xref target="RFC7469"/>, especially if the POSH client shares some information with a common HTTPS implementation (e.g., platform-default web browser).</t>
      <t>Note well that POSH is used by a POSH client to obtain the public key of a POSH server to which it might connect for a particular application protocol such as IMAP or XMPP.  POSH does not enable a hosted domain to transfer private keys to a hosting service via HTTPS.  POSH also does not enable a POSH server to engage in certificate enrollment with a certification authority via HTTPS, as is done in Enrollment over Secure Transport <xref target='RFC7030'/>.</t>
      <t>A web server at the Source Domain might redirect an HTTPS request to another URL.  The location provided in the redirect response MUST specify an HTTPS URL.  Source domains SHOULD use only temporary redirect mechanisms, such as HTTP status codes 302 (Found) and 307 (Temporary Redirect).  Clients MAY treat any redirect as temporary, ignoring the specific semantics for 301 (Moved Permanently) and 308 (Permanent Redirect) <xref target='RFC7538'/>.  To protect against circular references, it is RECOMMENDED that POSH clients follow no more than 10 redirects, although applications or implementations can require that fewer redirects be followed.</t>
      <t>Hash function agility is an important quality to ensure secure operations in the face of attacks against the fingerprints obtained within verification materials.  Because POSH verification materials are relatively short-lived compared to long-lived credentials such as PKIX end-entity certificates (at least as typically deployed), entities that deploy POSH are advised to swap out POSH files if the hash functions in use are found to be subject to realistic attacks.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">
      &rfc2119;
      &rfc2818;
      &rfc4648;
      &rfc5246;
      &rfc5280;
      &rfc5785;
      &rfc6125;
      &rfc7159;
      &rfc7230;
    </references>

    <references title="Informative References">

<reference anchor='I-D.ietf-dane-srv'>
<front>
<title>Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records</title>
<author initials='T' surname='Finch' fullname='Tony Finch'>
    <organization />
</author>
<author initials='M' surname='Miller' fullname='Matthew Miller'>
    <organization />
</author>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='April' day='23' year='2015' />
<abstract><t>The DANE specification (RFC 6698) describes how to use TLSA resource records secured by DNSSEC (RFC 4033) to associate a server's connection endpoint with its TLS certificate.  However, application protocols that use SRV records (RFC 2782) to indirectly name the target server connection endpoints for a service domain cannot apply the rules from RFC 6698.  Therefore this document provides guidelines that enable such protocols to locate and use TLSA records.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-dane-srv-14' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dane-srv-14.txt' />
</reference>

<reference anchor='I-D.ietf-xmpp-dna'>
<front>
<title>Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<author initials='M' surname='Miller' fullname='Matthew Miller'>
    <organization />
</author>
<author initials='P' surname='Hancke' fullname='Philipp Hancke'>
    <organization />
</author>
<date month='March' day='24' year='2015' />
<abstract><t>This document improves the security of the Extensible Messaging and Presence Protocol (XMPP) in two ways.  First, it specifies how to establish a strong association between a domain name and an XML stream, using the concept of "prooftypes".  Second, it describes how to securely delegate a service domain name (e.g., example.com) to a target server host name (e.g., hosting.example.net), which is especially important in multi-tenanted environments where the same target server hosts a large number of domains.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-xmpp-dna-10' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-xmpp-dna-10.txt' />
</reference>

      &rfc2782;
      &rfc4033;
      &rfc5226;
      &rfc6120;
      &rfc6335;
      &rfc6555;
      &rfc6570;
      &rfc6698;
      &rfc6797;
      &rfc7030;
      &rfc7469;
      &rfc7538;

      <reference anchor='HASH-NAMES' target='http://www.iana.org/assignments/hash-function-text-names/hash-function-text-names.xhtml'>
        <front>
          <title>Hash Function Textual Names</title>
          <author/>
          <date/>
        </front>
      </reference>
    </references>

    <section title="Acknowledgements" anchor="acks">
      <t>Thanks to Thijs Alkemade, Philipp Hancke, Joe Hildebrand, and Tobias Markmann for their implementation feedback, and to Dave Cridland, Chris Newton, Max Pritikin, and Joe Salowey for their input on the specification.</t>
      <t>Thanks also to Dave Cridland as document shepherd, Joe Hildebrand as working group chair, and Ben Campbell as area director.</t>
      <t>Peter Saint-Andre wishes to acknowledge Cisco Systems, Inc., for employing him during his work on earlier draft versions of this document.</t>
    </section>

  </back>
</rfc>
